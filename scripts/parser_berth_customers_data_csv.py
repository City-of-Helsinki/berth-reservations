"""
This script is used to parse customers' data exported as csv files from the
old system. It expects files to have certain name and to have data in a certain
format. They should be in the same directory as this script.

Expected file names:
    - customers_10_years.csv
    - current_leases.csv
    - customers_boats_10_years.csv
    - customers_invoices_10_years.csv

This script will generate two json files with the data to be imported in the
helsinki profile and berth reservations' services:

1. "helsinki_profile_stubs.json"
The file will have the following format of contents:
    ...
    {
        "customer_id": "123",
        "first_name": "John",
        "last_name": "Doe",
        "email": "john.doe@example.com",
        "ssn": "123456-1234",
        "address": {
            "address": "Example street 1",
            "postal_code": "12321",
            "city": "Gotham City",
        },
        "phones": [
            "040-1234567",
            "091234567"
        ]
    },
    ...

2. "berth_profile_stubs.json"
The file will have the following format of contents:
    ...
    "313431": {
        "customer_id": "313431",
        "leases": [
            {
                "harbor_servicemap_id": "41074",
                "berth_number": 4,
                "start_date": "2019-06-10",
                "end_date": "2019-09-14",
                "boat_index": 0
            }
        ],
        "boats": [
            {
                "boat_type": "Perämoottorivene",
                "name": "McBoatface 111",
                "registration_number": "31123A",
                "width": "2.00",
                "length": "5.30",
                "draught": null,
                "weight": null
            }
        ],
        "orders": [
            {
                "created_at": "2019-12-02 00:00:00.000",
                "order_sum": "251.00",
                "vat_percentage": "25.0",
                "berth": {
                    "harbor_id": "41074",
                    "berth_number": 4
                },
                "comment": "Laskunumero: 247509 RAMSAYRANTA A 004"
            }
        ],
        "organization": {
            "type": "company",
            "name": "Nice Profitable Firm Ltd.",
            "address": "Mannerheimintie 1 A 1",
            "postal_code": "00100",
            "city": "Helsinki"
        },
        "comment": "VENEPAIKKA PERUTTU 9.1.2012 Hetu/Y-tunnus Timmistä: 01018000T"
    },
    "313432": {
        "customer_id": "313432",
        "leases": [
            {
                "harbor_servicemap_id": "40897",
                "berth_number": 17,
                "start_date": "2019-06-10",
                "end_date": "2019-09-14"
            }
        ],
        "boats": [
            {
                "boat_type": "Jollavene",
                "name": "My Boaty",
                "registration_number": "",
                "width": "1.40",
                "length": "3.30",
                "draught": null,
                "weight": 500
            }
        ],
        "orders": [],
        "comment": "",
    },
    "313433": { ... },
    "313434": { ... },
    ...

The first file - "helsinki_profile_stubs.json" - should be taken as is and
imported into helsinki profile servie using a custom Django admin page, made
specifically for this data import. In response it will return another json
file with the key-value pairs, where key is the customer_id taken from the
input and value is the UUID of the newly created profile object.

We then take this returned json file and combine it with the second json file
generated by this script - "berth_profile_stubs.json" - using another Python
script - "merge_profile_uuids.py" (for more info on how to use it, look for
its own docs within the script file). It will return "berth_profiles.json"
file in response.

This file will then be imported into berth-reservations backend using custom
import view in Django admin, that is expecting json file with this structure.
Profiles will be created using the UUIDs in the "id" field in order to have
them federated between berth-reservations and helsinki profile services.
"""

import csv
import json
import re
from collections import defaultdict
from decimal import Decimal, InvalidOperation

HELSINKI_PROFILE_STUBS = defaultdict(dict)
BERTH_RESERVATIONS_STUBS = defaultdict(dict)

SSN_REGEX = (
    r"^(0[1-9]|[12]\d|3[01])(0[1-9]|1[0-2])([0-9]\d\+|\d\d-|[0-9]\dA)\d{3}[\da-zA-Z]$"
)

BUSINESS_ID_REGEX = "^[0-9]{6,7}-[0-9]{1}$"

TIMMI_CUSTOMER_ID_REGEX = "^[0-9]{6,6}$"

HARBORS_TO_SERVICEMAP_IDS_MAP = {
    "AIRORANTA": "40393",
    "AURINKOLAHTI": "41636",
    "EHRENSTRÖMINTIE": "40971",
    "ELÄINTARHANLAHTI": "39913",
    "HIETALAHDENALLAS": "41390",
    "HONKALUOTO": "40672",
    "HOPEASALMI": "41926",
    "ISO-SARVASTO": "40166",
    "JAALARANTA": "40827",
    "KATAJANOKKA": "48272",
    "KELLOSAARENRANTA": "40310",
    "KIPPARLAHTI": "41189",
    "KOIVUNIEMEN VENESATAMA": "39950",
    "LAIVALAHTI": "40864",
    "LÄHTEELÄ": "40290",
    "MERIHAKA": "41454",
    "MERI-RASTILA": "41066",
    "MERISATAMA": "40948",
    "MERISATAMARANTA": "45995",
    "MUSTIKKAMAA": "40359",
    "NANDELSTADH": "42225",
    "NAURISSALMI": "40712",
    "PAJALAHTI": "41359",
    "PIKKU KALLAHDEN VENESATAMA": "40590",
    "PITKÄNSILLANRANTA": "41669",
    "POHJOISRANTA": "41150",
    "PORSLAHDEN VENESATAMA": "40842",
    "PUOTILA": "40897",
    "PURSILAHTI": "40800",
    "RAMSAYNRANTA": "41074",
    "RUOHOLAHDEN KANAVA": "40203",
    "SALMISAARI": "40535",
    "SAUKONPAASI": "40627",
    "SAUNALAHTI": "41857",
    "SILTAVUOREN VENESATAMA": "40876",
    "STRÖMSINLAHTI": "42276",
    "TAMMASAARENALLAS": "41472",
    "TERVASAARI": "42136",
    "VASIKKASAARI": "41415",
    "VUOSAARI": "41637",
    "VÄHÄNIITTY": "42130",
}

PIERS_TO_HARBOR_NAME_MAP = {  # some harbors are actually piers in the csv
    "EHRENSTRÖMINTIE 21": "EHRENSTRÖMINTIE",
    "EHRENSTRÖMINTIE 22": "EHRENSTRÖMINTIE",
    "PAJALAHTI 10": "PAJALAHTI",
    "PAJALAHTI 11": "PAJALAHTI",
    "PAJALAHTI 19": "PAJALAHTI",
    "VUOSAARENLAHDEN VENESATAMA": "VUOSAARI",
    "VUOSAARI A": "VUOSAARI",
    "VUOSAARI E": "VUOSAARI",
    "VUOSAARI F": "VUOSAARI",
}

BOAT_TYPES_MAP = {
    # boat type in Timmi : boat type name in Django
    "jolla": "Jollavene",
    "kanootti": "Jollavene",
    "kumivene": "Jollavene",
    "soutuvene": "Soutuvene",
    "perämoottorivene": "Perämoottorivene",
    "preämootttorivene": "Perämoottorivene",
    "perämoottirivene": "Perämoottorivene",
    "perämoo0ttorivene": "Perämoottorivene",
    "perämoottori": "Perämoottorivene",
    "ulkoperämoottori": "Perämoottorivene",
    "sisäperämoottorivene": "Sisäperämoottorivene",
    "sisäperämoottori": "Sisäperämoottorivene",
    "sisämoottorivene": "Sisäperämoottorivene",
    "sisäperäpoottori": "Sisäperämoottorivene",
    "vesiskootteri": "Sisäperämoottorivene",
    "keskimoottorivene": "Keskimoottorivene",
    "keskimoottori": "Keskimoottorivene",
    "moottoripursi": "Keskimoottorivene",
    "moottorivene": "Keskimoottorivene",
    "purjevene": "Purjevene / moottoripursi",
    "purjejolla": "Purjevene / moottoripursi",
    "purjeve": "Purjevene / moottoripursi",
    "katamaraani": "Purjevene / moottoripursi",
    "moottoripurjevene": "Purjevene / moottoripursi",
    "troolari": "Troolari",
    "iso-alus": "Suuri alus (yli 20t)",
    "iso alus": "Suuri alus (yli 20t)",
    "huvialus": "Suuri alus (yli 20t)",
}

VAT_ID_TO_PERCENTAGE_MAP = {
    "12": "0.0",
    "15": "0.0",
    "18": "22.0",
    "25": "23.0",
    "26": "25.0",
}


def init_profile_stubs(customer_id):
    HELSINKI_PROFILE_STUBS[customer_id] = {
        "customer_id": customer_id,
        "phones": [],
    }
    BERTH_RESERVATIONS_STUBS[customer_id] = {
        "customer_id": customer_id,
        "leases": [],
        "boats": [],
        "orders": [],
        "comment": "",
    }


def _parse_boat_dict_from_row(row):
    # Since perämoottorivene are accepted to almost all harbors, consider it as default
    boat_type = "Perämoottorivene"
    if row["boat_type"].lower() in BOAT_TYPES_MAP.keys():
        boat_type = BOAT_TYPES_MAP.get(row["boat_type"].lower())

    try:
        boat_width = Decimal(row["boat_width"].strip() or 0)
        boat_length = Decimal(row["boat_length"].strip() or 0)
    except InvalidOperation:
        boat_width = Decimal(0)
        boat_length = Decimal(0)

    if all(
        [
            boat_length,
            boat_width,
            # Some of the rows have some random big integers for these values, filter them out
            boat_length < Decimal("50"),
            boat_width < Decimal("30"),
        ]
    ):
        try:
            boat_draught = Decimal(row["boat_draught"].strip())
            if boat_draught == Decimal(0):
                boat_draught = None
            else:
                boat_draught = str(boat_draught)
        except InvalidOperation:
            boat_draught = None

        try:
            boat_weight = int(float(row["boat_weight"].strip()))
        except (ValueError, TypeError):
            boat_weight = None

        return {
            "boat_type": boat_type,
            "name": row["boat_name"].strip().capitalize(),
            "registration_number": row["boat_registration_id"].strip().upper(),
            # Now that we have did proper checks with Decimal values,
            # convert width and length to str for json serialization
            "width": str(boat_width),
            "length": str(boat_length),
            "draught": boat_draught,
            "weight": boat_weight if boat_weight else None,
        }

    else:
        return None


def _parse_profile_stubs_from_old_customer_data(csv_row):
    customer_id = csv_row["customer_id"]

    # Init stub for profile data
    init_profile_stubs(customer_id)

    HELSINKI_PROFILE_STUBS[customer_id].update(
        {
            "first_name": csv_row["first_names"].strip().title(),
            "last_name": csv_row["last_name"].strip().title(),
        }
    )

    # Start building comment string
    comment = ""
    comment_from_csv = csv_row["comment"].strip()
    if comment_from_csv and comment_from_csv != "NULL":
        comment = comment_from_csv

    email = csv_row["email"].strip().lower()
    if email:
        if " " in email or "@" not in email:
            # Noise in email field, let's store it in the comment field
            comment += " Email: " + email
        else:
            HELSINKI_PROFILE_STUBS[customer_id]["email"] = email

    _phones = [
        csv_row["phone_1"].strip(),
        csv_row["phone_2"].strip(),
        csv_row["phone_3"].strip(),
    ]
    # Filter out empty phone values
    phones = list(filter(None, _phones))
    HELSINKI_PROFILE_STUBS[customer_id]["phones"] = phones

    street_address = csv_row["address"].strip().title()
    postal_code = csv_row["postal_code"].strip()
    city = csv_row["municipality"].strip().title()

    # Address fields in helsinki profile can not be blank
    address_dict = {
        "address": street_address or "-",
        "postal_code": postal_code or "-",
        "city": city or "-",
    }

    ssn_business_id = csv_row["ssn_business_id"].strip()

    if ssn_business_id:

        if re.match(SSN_REGEX, ssn_business_id):
            # This is an individual customer with valid SSN
            HELSINKI_PROFILE_STUBS[customer_id]["ssn"] = ssn_business_id
            HELSINKI_PROFILE_STUBS[customer_id]["address"] = address_dict

        elif ssn_business_id.startswith(("y", "Y")) or re.match(
            BUSINESS_ID_REGEX, ssn_business_id
        ):
            # This is quite likely a company customer
            BERTH_RESERVATIONS_STUBS[customer_id]["organization"] = {
                "type": "company",
                # cut to max_length=32 of the model field just in case
                "business_id": ssn_business_id[:32],
                "address": street_address,
                "postal_code": postal_code,
                "city": city,
            }

        else:
            # This customer has unclear data
            # Store ssn_business_id value in the comment field
            comment += " Hetu/Y-tunnus Timmistä: " + ssn_business_id
            HELSINKI_PROFILE_STUBS[customer_id]["address"] = address_dict

    # If no ssn_business_id value
    else:
        # Just store the address in Helsinki Profile, like for individual customers
        HELSINKI_PROFILE_STUBS[customer_id]["address"] = address_dict

    # Now we can store the comment too
    if comment:
        BERTH_RESERVATIONS_STUBS[customer_id]["comment"] = comment.strip()


def handle_customers_10_years_csv(csv_filename):
    with open(csv_filename, "r") as customers_10_years_csv:
        fieldnames = [
            "customer_id",
            "customer_number",
            "last_name",
            "first_names",
            "title",  # not used
            "ssn_business_id",
            "business_id",  # not used
            "ssn",  # not used
            "partner_code",  # not used
            "address",
            "postal_code",
            "municipality",
            "phone_1",
            "phone_2",
            "phone_3",
            "fax",  # not used
            "internal",  # not used
            "passive",  # not used
            "email",
            "www_url",  # not used
            "comment",
        ]

        # Skip first row as we pass our own headers
        next(customers_10_years_csv)

        csv_file_reader = csv.DictReader(
            customers_10_years_csv, delimiter=";", fieldnames=fieldnames
        )

        previous_row = None

        for row in csv_file_reader:
            # Is this row just a continuation of the previous one?
            # Actual new row should have 6 digit customer ID in the first cell
            if not re.fullmatch(TIMMI_CUSTOMER_ID_REGEX, row["customer_id"]):
                current_row_as_string = " ".join(filter(None, row.values()))
                previous_row["comment"] += " " + current_row_as_string
                continue

            # If not, and if previous_row is already
            #  assigned it is safe to parse it
            elif previous_row:
                _parse_profile_stubs_from_old_customer_data(previous_row)

            # Strip whitespaces from the comment
            row["comment"] = row["comment"].strip()

            previous_row = row


def handle_current_leases_csv(csv_filename):  # noqa: C901  too complex
    with open(csv_filename, "r") as current_leases_csv:
        fieldnames = [
            "harbor",
            "pier",
            "place_number",
            "place_type",
            "place_width",
            "place_length",
            "place_depth",
            "customer_id",
            "customer_name",
            "address",
            "postal_code",
            "city",
            "email",
            "business_id",  # not used
            "ssn",  # not used
            "phone",
            "boat_name",
            "boat_type",
            "boat_registration_id",
            "boat_width",
            "boat_length",
            "boat_draught",
            "boat_weight",
        ]

        # Skip first row as we pass our own headers
        next(current_leases_csv)

        csv_file_reader = csv.DictReader(
            current_leases_csv, delimiter=";", fieldnames=fieldnames
        )

        for row in csv_file_reader:
            customer_id = row["customer_id"]

            if not re.fullmatch(TIMMI_CUSTOMER_ID_REGEX, row["customer_id"]):
                # This row only has berth data, no customer data, skip it
                continue

            if customer_id not in HELSINKI_PROFILE_STUBS.keys():
                # This customer was not mentioned in the previous files, init its stubs
                init_profile_stubs(customer_id)

            full_name = row["customer_name"].strip().title()

            previously_seen_organization = BERTH_RESERVATIONS_STUBS[customer_id].get(
                "organization"
            )

            # Berth used by non-billable and other organizations
            if "kuva/" in full_name.lower() or " ry" in full_name.lower():
                BERTH_RESERVATIONS_STUBS[customer_id]["organization"] = {
                    "type": "non-billable" if "kuva/" in full_name.lower() else "other",
                    "name": full_name,
                    "address": row["address"].strip().title(),
                    "postal_code": row["postal_code"].strip().title(),
                    "city": row["city"].strip().title(),
                }
                # Ensure we don't import any address info into profile backend
                HELSINKI_PROFILE_STUBS[customer_id].pop("address", None)

            # Or maybe this is a customer that we have already identified as organization
            elif previously_seen_organization:
                BERTH_RESERVATIONS_STUBS[customer_id]["organization"][
                    "name"
                ] = full_name

            # Otherwise, let's handle this a regular individual customer
            elif " " in full_name:
                last_name, first_name = full_name.split(" ", 1)
                HELSINKI_PROFILE_STUBS[customer_id]["last_name"] = last_name
                HELSINKI_PROFILE_STUBS[customer_id]["first_name"] = first_name
            elif full_name:
                HELSINKI_PROFILE_STUBS[customer_id]["last_name"] = full_name

            previously_seen_email = HELSINKI_PROFILE_STUBS[customer_id].get("email")
            email = row["email"].strip().lower()

            if email and email != "null" and previously_seen_email != email:
                if "@" in email and " " not in email:
                    HELSINKI_PROFILE_STUBS[customer_id]["email"] = email
                else:
                    if BERTH_RESERVATIONS_STUBS[customer_id]["comment"]:
                        BERTH_RESERVATIONS_STUBS[customer_id]["comment"] += (
                            " Email: " + email
                        )
                    else:
                        BERTH_RESERVATIONS_STUBS[customer_id]["comment"] += (
                            "Email: " + email
                        )

            phone = row["phone"].strip()
            if phone and phone not in HELSINKI_PROFILE_STUBS[customer_id]["phones"]:
                HELSINKI_PROFILE_STUBS[customer_id]["phones"].append(phone)

            harbor_name = row["harbor"]
            if harbor_name and harbor_name in PIERS_TO_HARBOR_NAME_MAP.keys():
                harbor_name = PIERS_TO_HARBOR_NAME_MAP.get(harbor_name)

            berth_number = row["place_number"][:3]
            if berth_number.isdigit():
                berth_number = int(berth_number)

            lease_from_row = {
                "harbor_servicemap_id": HARBORS_TO_SERVICEMAP_IDS_MAP.get(harbor_name),
                "berth_number": berth_number,
                # The file has leases for the season 2019, let's hardcode the dates
                "start_date": "2019-06-10",
                "end_date": "2019-09-14",
            }

            boat_dict = _parse_boat_dict_from_row(row)
            if boat_dict:
                # This boat will be put in the "boats" list,
                # so we link it to this row's "lease" object
                lease_from_row["boat_index"] = len(
                    BERTH_RESERVATIONS_STUBS[customer_id]["boats"]
                )
                BERTH_RESERVATIONS_STUBS[customer_id]["boats"].append(boat_dict)

            BERTH_RESERVATIONS_STUBS[customer_id]["leases"].append(lease_from_row)


def handle_customers_boats_10_years_csv(csv_filename):
    with open(csv_filename, "r") as customers_boats_csv:
        fieldnames = [
            "customer_id",
            "boat_name",
            "boat_type",
            "boat_registration_id",
            "boat_width",
            "boat_length",
            "boat_draught",
            "boat_weight",
        ]

        # Skip first row as we pass our own headers
        next(customers_boats_csv)

        csv_file_reader = csv.DictReader(
            customers_boats_csv, delimiter=";", fieldnames=fieldnames
        )

        for row in csv_file_reader:
            customer_id = row["customer_id"]

            if customer_id not in HELSINKI_PROFILE_STUBS.keys():
                # This customer was not mentioned in the previous files, init its stubs
                init_profile_stubs(customer_id)

            if row["boat_type"].lower() == "parkkipaikka":
                # Do not even try to import randomly exported parking places
                continue

            boat_dict = _parse_boat_dict_from_row(row)
            if (
                boat_dict
                and boat_dict not in BERTH_RESERVATIONS_STUBS[customer_id]["boats"]
            ):
                BERTH_RESERVATIONS_STUBS[customer_id]["boats"].append(boat_dict)


def handle_customers_invoices_10_years_csv(csv_filename):
    with open(csv_filename, "r") as customers_invoices_csv:
        fieldnames = [
            "invoice_id",
            "invoice_breakdown_id",
            "invoice_number",
            "date",
            "invoice_sum",
            "customer_id",
            "comment_1",
            "comment_2",
            "invoice_breakdown_sum",
            "tax_id",
        ]

        # Skip first row as we pass our own headers
        next(customers_invoices_csv)

        csv_file_reader = csv.DictReader(
            customers_invoices_csv, delimiter=";", fieldnames=fieldnames
        )

        for row in csv_file_reader:
            customer_id = row["customer_id"]

            if customer_id not in HELSINKI_PROFILE_STUBS.keys():
                # This customer was not mentioned in the previous files, init its stubs
                init_profile_stubs(customer_id)

            # Store order number in the comment
            comment = "Laskunumero: " + row["invoice_number"] + " "

            # Let's try to parse berth related to this order
            berth = None
            harbor_name, berth_number = row["comment_1"].strip().rsplit(" ", 1)
            if harbor_name in PIERS_TO_HARBOR_NAME_MAP.keys():
                harbor_name = PIERS_TO_HARBOR_NAME_MAP.get(harbor_name)
            harbor_id = HARBORS_TO_SERVICEMAP_IDS_MAP.get(harbor_name)
            if harbor_id and berth_number.isdigit():
                berth = {"harbor_id": harbor_id, "berth_number": int(berth_number)}
                comment += row["comment_2"].strip()
            else:
                # Could not parse berth data, let's just save as one big comment
                comment += row["comment_1"].strip() + " " + row["comment_2"].strip()

            order_dict = {
                "created_at": row["date"].strip(),
                "order_sum": row["invoice_sum"],
                "vat_percentage": VAT_ID_TO_PERCENTAGE_MAP.get(row["tax_id"]),
                "berth": berth,
                "comment": comment.strip(),
            }

            BERTH_RESERVATIONS_STUBS[customer_id]["orders"].append(order_dict)


def save_helsinki_profile_stubs_to_json():
    with open("helsinki_profile_stubs.json", "w") as json_file:
        json.dump(HELSINKI_PROFILE_STUBS, json_file, ensure_ascii=False, indent=2)


def save_berth_profile_stubs_to_json():
    with open("berth_profile_stubs.json", "w") as json_file:
        json.dump(BERTH_RESERVATIONS_STUBS, json_file, ensure_ascii=False, indent=2)


if __name__ == "__main__":
    handle_customers_10_years_csv("customers_10_years.csv")
    handle_current_leases_csv("current_leases.csv")
    handle_customers_boats_10_years_csv("customers_boats_10_years.csv")
    handle_customers_invoices_10_years_csv("customers_invoices_10_years.csv")

    save_helsinki_profile_stubs_to_json()
    save_berth_profile_stubs_to_json()
